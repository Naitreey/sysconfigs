#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fileencoding=utf-8

import os
from subprocess import run
from shlex import split
from glob import iglob
from pathlib import Path
from contextlib import contextmanager
from shutil import copytree, copy
import yaml
from os.path import abspath, expanduser, isdir, exists, join, basename
import re
from colorama import Fore

DISTROS = ["ubuntu", "fedora", "arch"]

PKG_CMD = {
    # 0 - command to update package database
    # 1 - command to install package
    "arch": [
        split("sudo pacman -Syy"), split("sudo pacman -S")
    ],
}

@contextmanager
def enterdir(dir_):
    pwd = Path()
    os.chdir(dir_)
    try:
        yield Path()
    finally:
        os.chdir(pwd)

def info(msg):
    print(Fore.GREEN + f"*** {msg} ***" + Fore.RESET)

def warning(msg):
    print(Fore.YELLOW + f"*** {msg} ***" + Fore.RESET)

def current_distro():
    distro_regex = re.compile(r"(%s)" % "|".join(DISTROS))
    with open("/etc/os-release", "r") as f:
        release_info = f.read().lower()
    match = distro_regex.search(release_info)
    if not match:
        raise UnknownDistro("The current linux distribution"
                            " cannot be recognized")
    return match.group(1)

class InstallError(Exception):
    pass

class UnknownDistro(InstallError):
    pass

class DistroNotSupported(InstallError):
    pass

class FormatError(InstallError):
    pass

class ConfigModule:

    pkgsfmt     = "packages.d/packages-{distro}.yaml"
    filesfmt    = "files.d/files-{distro}.yaml"
    sourcedir   = "files.d/source"
    prehookfmt  = "hooks.d/preinstall-{distro}"
    posthookfmt = "hooks.d/postinstall-{distro}"

    def __init__(self, path, distro=current_distro()):
        self._distro = distro
        self._modulepath = Path(path).resolve(strict=True)
        self._pkgs = self._load_check_pkgs()
        self._files = self._load_check_files()
        self._prehook = self._load_check_prehook()
        self._posthook = self._load_check_posthook()

    def _load_check_pkgs(self):
        pkgsfile = self.pkgsfmt.format(distro=self._distro)
        if not exists(pkgsfile):
            pkgsfile = self.pkgsfmt.format(distro="any")
            if not exists(pkgsfile):
                return []
        with open(pkgsfile, "r") as f:
            packages = yaml.load(f)
        try:
            for p in packages:
                assert isinstance(p, str)
        except Exception as e:
            raise FormatError(f"invalid format of {pkgsfile}") from e
        else:
            return packages

    def _load_check_files(self):
        filesfile = self.filesfmt.format(distro=self._distro)
        if not exists(filesfile):
            filesfile = self.filesfmt.format(distro="any")
            if not exists(filesfile):
                return []
        with open(filesfile, "r") as f:
            files = yaml.load(f)
        try:
            for config in files:
                assert isinstance(config['source'], str)
                assert isinstance(config['target'], str)
                assert isinstance(config.get("copy", False), bool)
        except Exception as e:
            raise FormatError(f"invalid format of {filesfile}") from e
        else:
            return files

    def _load_check_prehook(self):
        prehook = self.prehookfmt.format(distro=self._distro)
        if not exists(prehook):
            prehook = self.prehookfmt.format(distro="any")
            if not exists(prehook):
                return None
        return prehook

    def _load_check_posthook(self):
        posthook = self.posthookfmt.format(distro=self._distro)
        if not exists(posthook):
            posthook = self.posthookfmt.format(distro="any")
            if not exists(posthook):
                return None
        return posthook

    def _get_backup_name(self, filepath):
        get_index = lambda fn: int(Path(fn).suffix[1:])
        backup_indices = sorted(get_index(p) for p in iglob(filepath+".orig.*"))
        if not backup_indices:
            next_index = 1
        else:
            next_index = backup_indices[-1] + 1
        return filepath + ".orig.%d" % next_index

    def _rename_if_exists(self, file):
        if exists(file):
            backup_name = self._get_backup_name(file)
            warning("{0} exists, renamed to {1}".format(
                file, backup_name
            ))
            os.rename(file, backup_name)

    def _link(self, target, link_name):
        self._rename_if_exists(link_name)
        os.symlink(abspath(target), link_name,
                   target_is_directory=isdir(target))

    def _copy(self, source, target):
        self._rename_if_exists(target)
        if isdir(source):
            copytree(source, target)
        else:
            copy(source, target)

    def run_prehook(self):
        info("Running pre-installation hook")
        if self._prehook:
            run([self._prehook], check=True)

    def run_posthook(self):
        info("Running post-installation hook")
        if self._posthook:
            run([self._posthook], check=True)

    def install_packages(self):
        info("Installing packages")
        if self._pkgs:
            run(PKG_CMD[self._distro][1] + self._pkgs, check=True)

    def install_configs(self):
        info("Installing configurations")
        for config in self._files:
            source, target = config['source'], config['target']
            print(f"{source} --> {target}")
            if config.get("copy", False):
                self._copy(
                    join(self.sourcedir, source),
                    target
                )
            else:
                self._link(
                    join(self.sourcedir, source),
                    target
                )

    def install(self):
        self.run_prehook()
        self.install_packages()
        self.install_configs()
        self.run_posthook()

class Installer:

    def __init__(self):
        self._distro = current_distro()
        self._modulesdir = (Path()/"modules.d").resolve(strict=True)

    def check_support(self):
        distro = self._distro
        if distro == "ubuntu" or distro == "fedora":
            raise DistroNotSupported(f"Support for {distro} coming soon")

    def install_all_modules(self):
        for path in sorted(self._modulesdir.glob("[0-9][0-9][0-9][0-9]?*")):
            info(f"installing {path.name}")
            with enterdir(path):
                module = ConfigModule(path, distro=self._distro)
                module.install()

    def cleanup(self):
        run(split("git clean -f -d -x"), check=True)

    def refresh_pkg_cache(self):
        run(PKG_CMD[self._distro][0], check=True)

    def run(self):
        self.check_support()
        self.cleanup()
        self.refresh_pkg_cache()
        self.install_all_modules()

def main():
    Installer().run()

if __name__ == "__main__":
    main()
