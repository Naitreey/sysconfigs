#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# vim:fileencoding=utf-8

from argparse import ArgumentParser
from colorama import Fore
from contextlib import contextmanager
from glob import iglob
from os.path import (
    abspath,
    expanduser,
    isdir,
    exists,
    lexists,
    join,
    basename,
    dirname,
    isfile,
)
from pathlib import Path
from shutil import copytree, copy
from subprocess import run
from shlex import split
import os
import re
import sys
import yaml

DISTROS = ["ubuntu", "fedora", "arch"]

PKG_CMD = {
    # 0 - command to update package database
    # 1 - command to install package
    "arch": [
        "pacman -Syy ", "pacman -S --noconfirm ",
    ],
    "fedora": [
        "dnf check-update || true ", "dnf install -y ",
    ],
}

@contextmanager
def enterdir(dir_):
    pwd = Path()
    os.chdir(dir_)
    try:
        yield Path()
    finally:
        os.chdir(pwd)

@contextmanager
def as_user(uid, gid):
    home_dir = os.environ.get('HOME')
    # When $HOME is present, expanduser() uses it directly.
    # It has to be deleted such that expanduser() looks at
    # real uid and /etc/passwd file for home directory.
    if home_dir:
        del os.environ['HOME']
    old_ruid, old_euid, old_suid = os.getresuid()
    old_rgid, old_egid, old_sgid = os.getresgid()
    os.setresgid(gid, gid, old_sgid)
    os.setresuid(uid, uid, old_suid)
    try:
        yield
    finally:
        os.setresgid(old_rgid, old_egid, old_sgid)
        os.setresuid(old_ruid, old_euid, old_suid)
        if home_dir:
            os.environ['HOME'] = home_dir

def info(msg):
    print(Fore.GREEN + f"*** {msg} ***" + Fore.RESET)

def warning(msg):
    print(Fore.YELLOW + f"*** {msg} ***" + Fore.RESET)

def error(msg):
    print(Fore.RED + f"*** {msg} ***" + Fore.RESET)

def current_distro():
    distro_regex = re.compile(r"(%s)" % "|".join(DISTROS))
    with open("/etc/os-release", "r") as f:
        release_info = f.read().lower()
    match = distro_regex.search(release_info)
    if not match:
        raise UnknownDistro("The current linux distribution"
                            " cannot be recognized")
    return match.group(1)

class InstallError(Exception):
    pass

class UnknownDistro(InstallError):
    pass

class DistroNotSupported(InstallError):
    pass

class FormatError(InstallError):
    pass

class ConfigModule:

    pkgsfmt     = "packages.d/packages-{distro}.yaml"
    filesfmt    = "files.d/files-{distro}.yaml"
    sourcedir   = "files.d/source"
    prehookfmt  = "hooks.d/preinstall-{distro}"
    posthookfmt = "hooks.d/postinstall-{distro}"

    def __init__(self, path, distro=current_distro()):
        self._distro = distro
        self._modulepath = Path(path).resolve(strict=True)
        self._pkgs = self._load_check_pkgs()
        self._files = self._load_check_files()
        self._prehook = self._load_check_prehook()
        self._posthook = self._load_check_posthook()

    def _load_check_pkgs(self):
        pkgsfile = self.pkgsfmt.format(distro=self._distro)
        if not lexists(pkgsfile):
            pkgsfile = self.pkgsfmt.format(distro="any")
            if not lexists(pkgsfile):
                return []
        with open(pkgsfile, "r") as f:
            packages = yaml.load(f)
        try:
            for p in packages:
                assert isinstance(p, str)
        except Exception as e:
            raise FormatError(f"invalid format of {pkgsfile}") from e
        else:
            return packages

    def _load_check_files(self):
        filesfile = self.filesfmt.format(distro=self._distro)
        if not lexists(filesfile):
            filesfile = self.filesfmt.format(distro="any")
            if not lexists(filesfile):
                return []
        with open(filesfile, "r") as f:
            files = yaml.load(f)
        try:
            for config in files:
                assert isinstance(config['source'], str)
                assert isinstance(config['target'], str)
                assert isinstance(config.get("copy", False), bool)
        except Exception as e:
            raise FormatError(f"invalid format of {filesfile}") from e
        else:
            return files

    def _load_check_prehook(self):
        prehook = self.prehookfmt.format(distro=self._distro)
        if not lexists(prehook):
            prehook = self.prehookfmt.format(distro="any")
            if not lexists(prehook):
                return None
        return prehook

    def _load_check_posthook(self):
        posthook = self.posthookfmt.format(distro=self._distro)
        if not lexists(posthook):
            posthook = self.posthookfmt.format(distro="any")
            if not lexists(posthook):
                return None
        return posthook

    def _get_backup_name(self, filepath):
        get_index = lambda fn: int(Path(fn).suffix[1:])
        backup_indices = sorted(get_index(p) for p in iglob(filepath+".orig.*"))
        if not backup_indices:
            next_index = 1
        else:
            next_index = backup_indices[-1] + 1
        return filepath + ".orig.%d" % next_index

    def _rename_if_exists(self, file):
        if lexists(file):
            backup_name = self._get_backup_name(file)
            warning("{0} exists, renamed to {1}".format(
                file, backup_name
            ))
            os.rename(file, backup_name)

    def _link(self, target, link_name):
        self._rename_if_exists(link_name)
        os.symlink(abspath(target), link_name,
                   target_is_directory=isdir(target))

    def _copy(self, source, target):
        self._rename_if_exists(target)
        if isdir(source):
            copytree(source, target)
        else:
            copy(source, target)

    def run_prehook(self):
        info("Running pre-installation hook")
        if self._prehook:
            run([self._prehook], check=True)

    def run_posthook(self):
        info("Running post-installation hook")
        if self._posthook:
            run([self._posthook], check=True)

    def install_packages(self):
        info("Installing packages")
        if self._pkgs:
            with as_user(uid=0, gid=0):
                run(PKG_CMD[self._distro][1] + " ".join(self._pkgs),
                    shell=True, check=True)

    def install_configs(self):
        def copy_or_link(source, target):
            target = expanduser(target)
            os.makedirs(dirname(target), exist_ok=True)
            if config.get("copy", False):
                self._copy(
                    join(self.sourcedir, source),
                    target
                )
            else:
                self._link(
                    join(self.sourcedir, source),
                    target
                )

        info("Installing configurations")
        for config in self._files:
            source, target = config['source'], config['target']
            print(f"{source} --> {target}")
            if config.get("asroot", False):
                with as_user(uid=0, gid=0):
                    copy_or_link(source, target)
            else:
                copy_or_link(source, target)

    def install(self):
        self.run_prehook()
        self.install_packages()
        self.install_configs()
        self.run_posthook()

class Installer:

    def __init__(self):
        self._distro = current_distro()
        self._modulesdir = (Path()/"modules.d").resolve(strict=True)
        self.check_support()

    def check_support(self):
        distro = self._distro
        if distro == "ubuntu":
            raise DistroNotSupported(f"Support for {distro} coming soon")

    def install_one_module(self, path):
        info(f"installing {path.name}")
        with enterdir(path):
            module = ConfigModule(path, distro=self._distro)
            module.install()

    def install_all_modules(self, start_at=None):
        for path in self.iter_module_paths(start_at):
            self.install_one_module(path)

    def cleanup(self):
        run(split("git clean -f -d -x"), check=True)

    def get_annex_files(self):
        run(split("git annex get --all"), check=True)

    def refresh_pkg_cache(self):
        with as_user(uid=0, gid=0):
            run(PKG_CMD[self._distro][0], shell=True, check=True)

    def iter_module_paths(self, start_at=None):
        if not start_at:
            return sorted(self._modulesdir.glob("[0-9][0-9][0-9][0-9]?*"))
        else:
            return filter(
                lambda p: p.name >= start_at,
                sorted(self._modulesdir.glob("[0-9][0-9][0-9][0-9]?*"))
            )

    def run(self, module=None, start_at=None, list=False):
        if list:
            print("\n".join(p.name for p in self.iter_module_paths()))
            return
        self.check_support()
        self.cleanup()
        self.get_annex_files()
        self.refresh_pkg_cache()
        if not module:
            self.install_all_modules(start_at)
        else:
            self.install_one_module(self._modulesdir/module)

def parse_args():
    parser = ArgumentParser(description="Configuration module installer.")
    mutex_group = parser.add_mutually_exclusive_group()
    mutex_group.add_argument("module",
                        nargs="?",
                        help="module to be installed")
    mutex_group.add_argument("--list", "-l",
                        action="store_true",
                        help="list available modules")
    mutex_group.add_argument("--start-at", "-t",
                        metavar="MODULE",
                        help="install modules starting at MODULE.")
    args = parser.parse_args()
    return args

def get_actual_ugid():
    """
    'actual u/gid' is normally the current effective u/gid,
    If invoked via sudo, it should be SUDO_UID/SUDO_GID.
    """
    try:
        actual_uid = int(os.getenv("SUDO_UID"))
    except TypeError:
        actual_uid = os.geteuid()
    try:
        actual_gid = int(os.getenv("SUDO_GID"))
    except TypeError:
        actual_gid = os.getegid()
    return actual_uid, actual_gid

def check_sudo():
    try:
        sudo_uid = int(os.getenv("SUDO_UID"))
    except TypeError:
        sudo_uid = None
    # bail out if we are effective root but not sudo-root
    if os.geteuid() == 0 and sudo_uid is None:
        raise InstallError("You must 'sudo' to run this as root.")

def main():
    args = parse_args()
    check_sudo()
    actual_uid, actual_gid = get_actual_ugid()
    installer = Installer()
    with as_user(uid=actual_uid, gid=actual_gid):
        installer.run(**args.__dict__)

if __name__ == "__main__":
    main()
